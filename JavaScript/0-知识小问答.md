**问：为什么有的编程规范要求用 void 0 代替 undefined？** 

答：在 JavaScript 中 undefined 是一个变量，而并非是一个关键字，这是 JavaScript 语言公认的设计失误之一，为了避免无意中被篡改，建议使用 void 0 来获取 undefined 值。



**问：字符串有最大长度吗？** 

答：有，字符串的最大长度是由字符数和内存限制共同决定的。

在大多数现代浏览器和 JavaScript 引擎中，字符串的最大长度通常可以达到 2^53 - 1个字符。这是由 JavaScript 引擎内部使用的 64 位浮点数表示字符串的长度所决定的。

然而实际上，由于内存限制和性能考虑，字符串的实际最大长度可能会受到更严格的限制。在不同的 JavaScript 引擎和环境中，这个限制可能会有所不同。此外，浏览器和设备的可用内存也会对字符串的最大长度产生影响。

需要注意的是，尝试创建非常大的字符串可能会导致性能问题，并且可能超出可用的内存限制。因此，在实际开发中，应根据具体需求和目标环境来管理和处理字符串的长度。



**问：0.1 + 0.2 不是等于 0.3 么？为什么 JavaScript 里不是这样的？**

答：因为 JavaScript 使用 IEEE 754 标准中的**双精度浮点数表示法**来存储和操作数字。

在这种表示法中，浮点数是以二进制形式存储的，并且有限的二进制位数无法准确表示某些十进制小数。例如，0.1 和 0.2 这两个十进制小数在二进制表示中是无限循环的。

当进行浮点数运算时，JavaScript 引擎会尽力接近准确结果，但由于精度限制，可能会出现舍入误差。这就导致了 0.1 + 0.2 的结果不等于 0.3。

为了避免由于浮点数精度问题而导致的意外结果，建议在进行浮点数比较时，使用适当的精度范围或比较差值，而不是直接比较两个浮点数是否相等。例如：

```js
Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON    // true
```



**问： ES6 新加入的 Symbol 是个什么东西？** 

答：Symbol 是一种独一无二且不可变的数据类型，任何两个 Symbol 值都是不相等的，即使它们的描述符相同。可以用作对象属性的键 key。



**问：为什么给对象添加的方法能用在基本类型上？**

答：JavaScript 语言设计上试图模糊对象和基本类型之间的关系，而 `.` 运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。 



**问：Promise 里的代码为什么比 setTimeout 先执行？**

答：首先  Promise 产生的是 JavaScript 引擎内部的微任务，setTimeout 是浏览器 API 产生是宏任务。而一个循环中微任务始终先于宏任务。

当 Promise 被创建并执行时，它的回调函数会被添加到微任务队列中。然后，JavaScript 引擎会立即执行微任务队列中的所有任务，这意味着 Promise 的回调函数会在当前宏任务执行完毕之前立即执行。

相比之下，setTimeout 会将其回调函数添加到宏任务队列中。当所有的微任务执行完毕后，JavaScript 引擎会检查宏任务队列，并选择下一个宏任务执行。因此，setTimeout 中的回调函数需要等待当前的宏任务执行完毕后才会执行。



**问：var 和 let 有什么区别？**

答：

1. 变量作用域：使用 `var` 声明的变量具有函数作用域（function scope），而使用 `let` 声明的变量具有块级作用域（block scope）。
   - 函数作用域：在使用 `var` 声明的变量中，其作用域限定在最近的函数内。在函数内部声明的 `var` 变量在函数外部是不可访问的。
   - 块级作用域：使用 `let` 声明的变量的作用域限定在最近的块（例如，if 语句、循环、函数等）内。在块内部声明的 `let` 变量在块外部是不可访问的。
2. 变量提升：使用 `var` 声明的变量存在变量提升（hoisting）的特性，即变量的声明会被提升到当前作用域的顶部。这意味着你可以在变量声明之前访问该变量，但其值为 `undefined`。而使用 `let` 声明的变量不会发生变量提升，所以在变量声明之前访问会引发 ReferenceError。
3. 重复声明：使用 `var` 可以重复声明同一个变量而不会引发错误，而使用 `let` 在同一作用域内重复声明同一个变量会引发 SyntaxError。
4. 全局对象属性：使用 `var` 声明的全局变量会成为全局对象（例如，在浏览器中是 `window` 对象）的属性，而使用 `let` 声明的全局变量不会成为全局对象的属性。

综上所述，推荐在现代 JavaScript 中使用 `let` 来声明变量，因为它更符合预期的作用域规则，并且可以避免一些常见的问题。使用 `var` 主要是为了向后兼容旧版本的 JavaScript 或特定的使用场景。



**问：apply 和 call 方法有什么不同？**

答：它们都可以改变函数上下文，第一个参数都是作为函数上下文的对象，不同的是函数调用时的。前者的第二个参数是数组或类数组，后者的第二个参数是参数列表。



**问：JavaScript 在设计上有哪些被广泛认为是糟糕的方面？**

答：

1. 弱类型和隐式类型转换：JavaScript 是一种弱类型语言，这意味着变量的类型可以在运行时随意改变。此外，JavaScript 还会进行隐式类型转换，导致一些令人困惑和意外的行为。
2. 变量提升：JavaScript 中的变量提升是指变量和函数声明在代码执行之前就被提升到了作用域的顶部。这可能导致变量在声明之前被访问，从而引发错误或不符合预期的行为。
3. 全局变量污染：在 JavaScript 中，如果没有使用关键字声明变量（例如 `var`、`let` 或 `const`），变量会自动成为全局变量，这可能导致命名冲突和意外的副作用。
4. this 关键字的困扰：JavaScript 中的 this 关键字在不同的上下文中具有不同的含义，这经常导致开发人员困惑和错误的结果。
5. 作用域和闭包：JavaScript 的作用域规则有时会令人困惑，尤其是在涉及嵌套函数和闭包的情况下。这可能导致变量泄漏和意外的变量共享问题。
6. 数组和对象的处理：JavaScript 中的数组和对象处理方式相对较弱，缺乏一些常见的操作和方法。此外，数组和对象的比较和相等性判断也可能出现问题。
7. 不一致的标准库：JavaScript 的标准库在设计和功能上存在一些不一致性，导致开发人员需要依赖第三方库来弥补这些缺陷。

尽管 JavaScript 存在这些糟糕的设计方面，但也有很多开发者喜欢 JavaScript 的灵活性和易用性，并且社区也在不断努力改进和解决这些问题。



问：JavaScript 是什么语言？

答：解释型语言：

+ 但对于 JavaScript 来说，可以直接执行源码(比如：`node test.js`)，它是在运行的时候先编译再执行，这种方式被称为**即时编译(Just-in-time compilation)**，简称为 JIT。因此，V8 也属于 **JIT 编译器**。

+ JS编译结束之后，并不会生成存放在内存或者硬盘之中的目标代码或可执行文件。生成的指令字节码，会被立即被JSCore这台虚拟机进行逐行**解释执行**。

+ https://juejin.cn/post/6983896089703235592#heading-21

+ JavaScript 是一种解释型语言，而不是静态编译语言。在传统的编译语言中，源代码会经过编译器的处理，将其转换为机器代码，然后才能执行。而 JavaScript 是一种解释型语言，它的代码在运行时逐行解释执行，而不需要显式的编译步骤。

  当 JavaScript 代码在浏览器或其他 JavaScript 运行环境中执行时，解释器会逐行读取代码，并将其转换为可执行的指令。这种解释执行的方式使得 JavaScript 具有动态性和灵活性，可以在运行时进行动态的类型判断和代码执行。

  然而，现代的 JavaScript 引擎通常会使用即时编译（Just-In-Time Compilation）技术来提高代码的执行效率。引擎会在运行时对 JavaScript 代码进行优化和编译，以生成更高效的机器码。这种即时编译的技术使得 JavaScript 的执行速度能够接近一些静态编译语言的水平。

  总结起来，JavaScript 是一种解释型语言，但现代的 JavaScript 引擎使用即时编译技术来提高执行效率。