# 相关概念

## SPA

Single Page Application —— 单页面应用程序

+ 是前后端分离时提出的一种解决方案；
+ 在一个应用或者站点中，只有一个完整的 html 页面，这个页面有一个容器 root 节点，可以把需要加载的代码片段插入到该容器中；
+ SPA 的工作原理：采用的前端路由跳转子页面系统，通过改变页面的 URL，在不重新请求页面的情况下，实现局部更新页面视图。



## SEO

Search Engine Optimization —— 搜索引擎优化

+ 利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名；
+ SEO 的工作原理：网页在被请求的时候，从服务器发出的内容可以被搜索引擎的爬虫爬到数据，这个时候从搜索引擎搜索的关键字包含在这些内容中，那么这个网址的信息就更容易显示在搜索结果中。
+ 为什么服务端渲染更利于爬虫页面：
  + 低级爬虫，只请求URL，URL返回的 HTML 是什么内容就爬什么内容；
  + 高级爬虫，请求URL，加载并执行 JavaScript 脚本渲染页面，爬 JavaScript 渲染后的内容；
  + 低级爬虫对客户端渲染的页面来说简直无能为力，因为返回的 HTML 是一个空壳，它需要执行 JavaScript 脚本之后才会渲染真正的页面；
  + 而目前像百度、谷歌、微软等公司，有一部分年代老旧的爬虫还属于低级爬虫，使用服务端渲染，对这些低级爬虫更加友好一些。




# 渲染方式

## 后端渲染 - SSR

SSR Server Side Rendering

### 原理

+ 也叫传统服务端渲染、后端模板渲染，如 ASP、JAVA、JSP 或者 PHP；
+ 最早时期的 WEB，客户端请求时，在服务器上使用模板引擎将模板与数据拼接成完整的 HTML，再发送给客户端，客户端接收后直接解析 HTML 就可以在浏览器上展示出来，不需要额外的异步请求获取数据；
+ 但是这时候的 WEB 只能实现简单的信息展示，要使 WEB 有交互性，客户端需要再用 JS 去操作 DOM 或者渲染其他动态的部分。



### 优缺点

这个时期的服务器上面有模板、有读取数据的后端代码，还夹杂着很多 JS 的代码，这就导致了以下的一些不足：

+ 前后端职责不清；
+ 前后端代码杂揉在一起；
+ 项目难以管理和维护。



尽管如此，这种渲染方式还是有一些好处：

+ 客户端能够快速呈现服务器端渲染好的页面，减少白屏时间，这能够提供很好的用户体验；
+ SEO 友好，服务端渲染从服务器发出的 HTML 带有页面内容，可提高搜索排名。



## 前端渲染 - CSR

CSR Client Side Rendering

### 原理

+ 也叫客户端渲染；
+ 指使用 JS 来渲染页面大部分内容，代表是现在流行的 SPA 单页面应用，如 React 和 VUE；
+ 客户端在请求时，服务端不做任何处理，直接将前端资源打包后生成的 HTML 返回给客户端；
+ 此时的 HTML 中无任何网页内容，需要客户端去加载执行 JS 代码才能渲染生成页面内容，同时完成事件绑定，然后客户端再去通过 AJSX 请求后端 API 获取数据更新视图。



### 优缺点

+ 前后端代码解耦，两端使用 AJSX 进行交互实现局部刷新。 



但这种方式也有一些不足：

+ 首屏加载缓慢，因为要等 JS 加载完毕后，才能进行页面渲染；
+ SEO 不友好，SPA 模式的客户端渲染从服务器发出的只是一个没有内容的空壳，大部分页面内容通过 JS 渲染，搜索引擎自然爬不到东西；
+ 客户端渲染至少发起 HTTP 请求三次，第一次是请求页面，第二次是请求页面里的 JS 脚本，用于渲染 DOM 和事件绑定，第三次是动态数据 AJAX 请求。而服务端渲染将传统的 3 次串行 HTTP 请求简化成一次 HTTP 请求，客户端只需要请求页面，解析服务端返回的 HTML 即可；
+ 需要重复渲染，因为发送 AJAX 请求向后台获取数据，一般在 componentDidMounted 生命周期，页面已经渲染过一次，等到获取数据后更新视图，页面又需要再渲染一次。

  

## 同构渲染

SSR Server Side Rendering

Isomorphic rendering

### 原理

+ 在服务端渲染中，有两种页面渲染的方式：

  - 前端服务器通过请求后端服务器获取数据并组装 HTML 返回给浏览器，浏览器直接解析 HTML 后渲染页面；
  - 浏览器在交互过程中，请求新的数据并动态更新渲染页面；
  - 这两种渲染方式有一个不同点就是，一个是在服务端中组装 HTML 的，一个是在客户端中组装 HTML 的，运行环境是不一样的。


+ **同构**就是一套代码在服务器上运行一遍，到达浏览器又运行一遍，并且执行的效果都是一样的：
  + 代码在服务端执行的时候负责渲染页面，代码在浏览器执行的时候负责交互；
  + 服务端渲染完成页面结构，客户端渲染绑定事件；
  + 它是在 SPA 的基础上，利用服务端渲染直出首屏，解除单页面应用在首屏渲染上面临的窘境。
+ 将传统的纯服务端直出的首屏优势和 SPA 的站内体验优势结合起来。



### 实现同构渲染的技术支持

SSR 之所以能够实现，有两个重要前提：

- Node.js 的存在：
  - 同构渲染项目的 React.js 代码会在客户端和服务器端各执行一次，这得益于 Node 环境下能运行 JavaScript 代码，才使得同构成为可能；
  - JS 是脚本语言，需要一个解析器才能运行。对于写在 HTML 页面里的 JS，浏览器充当着解析器的角色。而对于需要独立运行的 JS，NodeJS 就是一个解析器；
  - 每一种解析器都是一个运行环境，不但允许 JS 定义各种数据结构，进行各种计算，还允许 JS 使用运行环境提供的内置对象和方法做一些事情。
    - 例如运行在浏览器中的 JS 的用途是操作 DOM，浏览器就提供了 document 之类的内置对象；
    - 而运行在 NodeJS 中的 JS 的用途是操作磁盘文件或搭建 HTTP 服务器，NodeJS 就相应提供了 fs、http 等内置对象。
- 虚拟 DOM 的存在：
  - React 在做页面操作时，实际上不是直接操作 DOM，而是通过操作虚拟 DOM 完成数据变化，也就是操作普通的 JavaScript 对象，这才使得同构渲染成为了可能；
  - JS 操作 DOM 的能力是浏览器给予它的， 而在 Node 环境下，是没有 DOM 这个概念存在的，如果你的 React 代码里存在直接操作 DOM 的代码，在 Node 环境下这些代码会报错，就无法实现同构了；
  - 但在 React 框架中引入了虚拟 DOM 这个概念，这样就可以在 JS 中创建 Virtual DOM 元素了；
  - 其他的一些框架，比如 Vue，它能够实现 SSR 也是因为引入了和 React 中一样的虚拟 DOM 技术。



### 优缺点

+ 首屏是服务端渲染，加快首屏渲染，优化 SEO；
+ 之后的页面跳转通过前端路由进行，遵循 SPA，支持局部刷新，前后端分离，减轻服务器压力。



同构渲染的引发的问题也不少：

+ 不能在服务端渲染期间操作 DOM、BOM API，比如 document、window 对象等，应尽量避免在首屏逻辑使用到它们；
+ 增加了代码的复杂度，某些代码操作需要区分运行环境；
+ 要注意不打包只在服务端运行的外部扩展库，否则会造成构建后的文件体积过大；
+ 为了实现服务端渲染，应用代码中需要兼容服务端和客户端两种运行情况，而一部分依赖的外部扩展库却只能在客户端运行，需要对其进行特殊处理，才能在服务器渲染应用程序中运行；
+ 需要更多的服务器负载均衡，由于服务器增加了渲染 HTML 的需求，使得原本只需要输出静态资源文件的Node.js 服务，新增了数据获取的 IO 和渲染 HTML 的 CPU 占用，如果流量突然暴增，有可能导致服务器宕机，因此需要使用响应的缓存策略和准备相应的服务器负载；
+ 与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境；
+ 同构考验开发人员对大局观的考虑，约束了特定环境的一些开发灵活性，同时也影响代码解耦，抛开了 SEO优化和首屏加载外没有任何好处，而这两者解决方案有很多，得不偿失。





# Reference

原理介绍：

+ [为什么现在又流行服务端渲染html？](https://www.zhihu.com/question/59578433/answer/326694511) 
+ [彻底理解服务端渲染 - SSR原理](https://github.com/yacan8/blog/issues/30#) 
+ [谈谈我对服务端渲染(SSR)的理解](https://juejin.cn/post/6890810591968477191) 
+ [知乎问答：什么是前端的同构渲染？](https://www.zhihu.com/question/325952676) 

实践：

+ [从头开始，彻底理解服务端渲染原理(8千字汇总长文)](https://zhuanlan.zhihu.com/p/76967335) 
+ [ReactDOMServer](https://reactjs.org/docs/react-dom-server.html) 

框架

+ [github项目：服务端渲染框架](https://github.com/zhangyuang/ssr) 